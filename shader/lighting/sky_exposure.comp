#version 450

#extension GL_EXT_control_flow_attributes : enable
#extension GL_GOOGLE_include_directive    : enable

#include "scene.glsl"
#include "common.glsl"

layout(push_constant, std430) uniform UboPush {
  float baseL;
  } push;

layout(local_size_x = 128) in;

const uint NumInvocations = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;
const uint HistMid        = (NumInvocations/2);

shared uint minLum, maxLum;
shared uint histogram[NumInvocations];

layout(binding = 0, std140) buffer UboScene {
  SceneDesc scene;
  };
layout(binding = 1) uniform sampler2D skyLUT;

void hInsert(float v) {
  uint value = floatBitsToUint(v);
  for(uint i=0; i<=HistMid; ++i){
    uint old = atomicMin(histogram[i], value);
    if(old == 0xFFFFFFFFu || old == value)
      break;
    value = max(old, value);
    }
  }

float luminosity(vec3 color) {
  return dot(color, vec3(0.2125, 0.7154, 0.0721));
  }

void processMinMax(vec3 val) {
  float lx = luminosity(val);
  hInsert(lx);

  uint  lu = floatBitsToUint(lx);
  atomicMin(minLum, lu);
  atomicMax(maxLum, lu);
  }

vec3 resolveMiss(const vec3 rayOrigin, const vec3 rayDirection) {
  // PERF: need to preload sky lut early in shader
  const vec3 lcolor  = textureSkyLUT(skyLUT, vec3(0,RPlanet,0), rayDirection, scene.sunDir) * scene.GSunIntensity;
  const vec3 ambient = scene.ambient * scene.sunColor;

  vec3 color = vec3(0);
  color += lcolor;
  return color;
  }

void gather() {
  const uint smpCount = 8;

  for(uint i=0; i<smpCount; ++i) {
    vec3 dir = sampleHemisphere(gl_LocalInvocationIndex*smpCount+i, gl_WorkGroupSize.x*smpCount, 0);

    vec3 sky = vec3(0);
    sky = resolveMiss(vec3(0), +dir);
    processMinMax(sky);

    //sky = resolveMiss(vec3(0), -dir);
    //processMinMax(sky);
    }
  }

void main() {
  minLum = -1;
  maxLum = 0;
  histogram[gl_LocalInvocationIndex] = -1;
  barrier();

  gather();
  barrier();

  if(gl_LocalInvocationIndex==0) {
    // float vmin = uintBitsToFloat(minLum);
    // float vmax = uintBitsToFloat(maxLum);
    float vmin = uintBitsToFloat(histogram[HistMid-1]);
    float vmax = uintBitsToFloat(histogram[HistMid-0]);

    float lum = (vmax+vmin) * 0.5;
    scene.exposure = 1.0 / max(lum*push.baseL, 0.000005);
    }
  }
