#version 450

#extension GL_GOOGLE_include_directive    : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_samplerless_texture_functions : enable
#extension GL_EXT_control_flow_attributes : enable
// bindless
#extension GL_EXT_nonuniform_qualifier : enable
// #extension GL_EXT_shader_explicit_arithmetic_types_float16 : enable
// #extension GL_KHR_memory_scope_semantics : enable

#include "common.glsl"
#include "scene.glsl"
#include "rtsm/rtsm_common.glsl"

#define TRANSLUCENCY 1

layout(local_size_x = 8, local_size_y = 8) in;

const uint NumThreads = gl_WorkGroupSize.x*gl_WorkGroupSize.y*gl_WorkGroupSize.z;

layout(push_constant, std430) uniform UboPush {
  vec3  originLwc;
  } push;
layout(binding = 0, rgba8)  uniform  image2D    outputImage;
layout(binding = 1, std140) uniform  UboScene   { SceneDesc scene; };
layout(binding = 2)         uniform  utexture2D gbufNormal;
layout(binding = 3)         uniform  texture2D  depth;
layout(binding = 4, std430) readonly buffer Pos { uint  alloc; uint    data[]; } pos;
layout(binding = 5, std430) readonly buffer Lbo { LightSource lights[];        };
layout(binding = 6, std430) readonly buffer VId { uvec4 count; LightId data[]; } vLights;

#define CONST_SCRATCH 1
#include "rtsm/rtsm_scratch.glsl"

ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);
vec3  light     = vec3(0);

vec3 rayTriangleTest(const vec3 origin, const vec3 raydir, const vec3 triA, const vec3 triB, const vec3 triC) {
  const float epsilon = 0.0001;

  vec3  edge1 = triB - triA;
  vec3  edge2 = triC - triA;
  vec3  ray_cross_e2 = cross(raydir, edge2);
  float det = dot(edge1, ray_cross_e2);

  if(det > -epsilon && det < epsilon)
    return vec3(-1);    // This ray is parallel to this triangle.

  float inv_det = 1.0 / det;
  vec3  s = origin - triA;
  float u = inv_det * dot(s, ray_cross_e2);

  if(u < 0 || u > 1)
    return vec3(-1);

  vec3 s_cross_e1 = cross(s, edge1);
  float v = inv_det * dot(raydir, s_cross_e1);

  if(v < 0 || u + v > 1)
    return vec3(-1);

  // At this stage we can compute t to find out where the intersection point is on the line.
  float t = inv_det * dot(edge2, s_cross_e1);

  if(t > epsilon) // ray intersection
    return vec3(t, u, v); //vec3(origin + raydir * t);

  // This means that there is a line intersection but not a ray intersection.
  return vec3(-1, u, v);
  }

shared uint  primitiveCnt;
shared uvec4 primitiveIds[MaxPrim];
shared vec3  vertices    [MaxVert];

void pullMeshlet(uint ptrM) {
  const uint laneID  = gl_LocalInvocationIndex;
  const uint primCnt = pullPrimitiveCount(ptrM);
  const uint vertCnt = pos.data[ptrM+4];

  if(laneID == 0)
    primitiveCnt = primCnt;

  ptrM += MeshletHeaderSize;
  if(laneID < primCnt)
    primitiveIds[laneID] = pullPrimitiveFull(ptrM, laneID);

  ptrM += MaxPrim;
  if(laneID < vertCnt)
    vertices[laneID] = pullVertex(ptrM, laneID);
  }

bool rayMeshletTest(const vec3 origin, const vec3 dir) {
  for(uint i=0; i<primitiveCnt; ++i) {
    const uvec3 prim = primitiveIds[i].xyz;
    const vec3  t    = rayTriangleTest(origin, dir, vertices[prim.x], vertices[prim.y], vertices[prim.z]);
    if(t.x>0)
      return true;
    }
  return false;
  }

void processLight(const vec3 origin, const vec3 normal, const LightId lId) {
  const LightSource src  = lights[lId.id];
  const uint        ptr  = lId.numMeshlets;
  const vec3        ldir = origin-src.pos;

  bool shadow = false;
  /*
  const uint numMeshlets = pos.data[ptr];
  for(uint i=0; i<numMeshlets; ++i) {
    pullMeshlet(pos.data[ptr+i+1]);
    barrier();

    if(!shadow)
      shadow = rayMeshletTest(src.pos, ldir);
    barrier();
    }
*/
  if(shadow)
    return;

  const float distanceSquare = dot(ldir,ldir);
  const float factor         = distanceSquare / (src.range * src.range);
  const float smoothFactor   = max(1.0 - factor * factor, 0.0);
  if(factor>1.0)
    return;

  float lambert = max(0.0,-dot(normalize(ldir),normal));
  float lx      = (lambert/max(factor, 0.05)) * (smoothFactor*smoothFactor);
  if(lx<=0.0)
    return;

  light += vec3(lx);
  }

vec3 worldPos(ivec2 frag, float depth) {
  const vec2 fragCoord = ((frag.xy+0.5)*scene.screenResInv)*2.0 - vec2(1.0);
  const vec4 scr       = vec4(fragCoord.x, fragCoord.y, depth, 1.0);
  const vec4 wpos      = scene.viewProjectLwcInv * scr;
  return wpos.xyz/wpos.w;
  }

void main() {
  const ivec2 size   = textureSize(depth, 0);
  const bool  valid  = all(lessThan(fragCoord, size));

  const vec3  normal = valid ? normalFetch(gbufNormal, fragCoord) : vec3(0);
  const float z      = valid ? texelFetch(depth, fragCoord, 0).x  : 1.0;

  const vec3  orig   = worldPos(fragCoord.xy, z) + (normal*NormalBias) + push.originLwc;

  if(vLights.count.x>0) {
    //TODO: many lights
    processLight(orig, normal, vLights.data[0]);
    }

  if(valid)
    imageStore(outputImage, ivec2(fragCoord), vec4(light, 1));
  }
