#version 450

#extension GL_GOOGLE_include_directive    : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_samplerless_texture_functions : enable

#include "virtual_shadow/vsm_common.glsl"
#include "scene.glsl"
#include "common.glsl"

#if defined(PASS0)
layout(local_size_x = 16, local_size_y = 8) in;
#else
layout(local_size_x = 8, local_size_y = 8) in;
#endif

layout(binding = 0, std430) buffer Pages { VsmHeader header; uint  pageList[]; } vsm;
layout(binding = 1, r32ui)  uniform uimage3D pageTbl;

void trimMip(int mip) {
  const ivec3 size = imageSize(pageTbl);
  const ivec3 id   = ivec3(gl_LocalInvocationID);

  const ivec2 b = ivec2(VSM_PAGE_TBL_SIZE/4);
  const ivec2 h = ivec2(VSM_PAGE_TBL_SIZE/2);

  for(int i=id.x; i<h.x; i+=int(gl_WorkGroupSize.x)) {
    for(int r=id.y; r<h.y; r+=int(gl_WorkGroupSize.y)) {
      ivec3 ax = ivec3(i+b.x, r+b.y, mip);
      uint  st = imageLoad(pageTbl, ax).r;
      if(st==0)
        continue;

      ivec3 at = ivec3(i*2, r*2, mip-1);
      uint  a  = imageLoad(pageTbl, at+ivec3(0,0,0)).r;
      uint  b  = imageLoad(pageTbl, at+ivec3(1,0,0)).r;
      uint  c  = imageLoad(pageTbl, at+ivec3(0,1,0)).r;
      uint  d  = imageLoad(pageTbl, at+ivec3(1,1,0)).r;
      if(a>0 && b>0 && c>0 && d>0) {
        imageStore(pageTbl, ax, uvec4(0));
        }
      }
    }
  }

void mainTrim() {
  const ivec3 size = imageSize(pageTbl);
  // NOTE: need only about 5 mips
  for(int i=1; i<size.z; ++i) {
    trimMip(i);
    barrier();
    }
  }

void mainGroups() {
  const ivec3 size = imageSize(pageTbl);
  const ivec3 at   = ivec3(gl_GlobalInvocationID);
  const ivec3 id   = ivec3(gl_LocalInvocationID);

  if(true && at.x%2==0 && at.y%2==0) {
    uint a = imageLoad(pageTbl, at+ivec3(0,0,0)).r;
    uint b = imageLoad(pageTbl, at+ivec3(1,0,0)).r;
    uint c = imageLoad(pageTbl, at+ivec3(1,1,0)).r;
    uint d = imageLoad(pageTbl, at+ivec3(0,1,0)).r;
    if(a==1 && b==1 && c==1 && d==1) {
      imageStore(pageTbl, at+ivec3(0,0,0), uvec4(2));
      imageStore(pageTbl, at+ivec3(1,0,0), uvec4(0));
      imageStore(pageTbl, at+ivec3(0,1,0), uvec4(0));
      imageStore(pageTbl, at+ivec3(1,1,0), uvec4(0));
      }
    }
  groupMemoryBarrier();
  barrier();

  if(true && at.x%4==0 && at.y%4==0) {
    uint a = imageLoad(pageTbl, at+ivec3(0,0,0)).r;
    uint b = imageLoad(pageTbl, at+ivec3(2,0,0)).r;
    uint c = imageLoad(pageTbl, at+ivec3(2,2,0)).r;
    uint d = imageLoad(pageTbl, at+ivec3(0,2,0)).r;
    if(a==2 && b==2 && c==2 && d==2) {
      imageStore(pageTbl, at+ivec3(0,0,0), uvec4(4));
      imageStore(pageTbl, at+ivec3(2,0,0), uvec4(0));
      imageStore(pageTbl, at+ivec3(0,2,0), uvec4(0));
      imageStore(pageTbl, at+ivec3(2,2,0), uvec4(0));
      }
    }
  }

void main() {
#if defined(PASS0)
  mainTrim();
#elif defined(PASS1)
  mainGroups();
#else
#error "invalid pass-id"
#endif
  }

/*
shared uint pageVal[gl_WorkGroupSize.x][gl_WorkGroupSize.y];
void main2() {
  const ivec3 size = imageSize(pageTbl);
  const ivec3 at   = ivec3(gl_GlobalInvocationID);
  const ivec3 id   = ivec3(gl_LocalInvocationID);

#if 0
  if(at.z==1) {
    uint pageS = 0;
    if(all(lessThan(at, size)))
      pageS = imageLoad(pageTbl, at).r;

    const int step = VSM_PAGE_TBL_SIZE/4;
    if(all(lessThan(ivec2(step), at.xy)) && all(lessThan(at.xy, ivec2(VSM_PAGE_TBL_SIZE-step)))) {
      ivec3 x = ivec3(ivec2(at.xy - step)*2, 0);

      bool t = (imageLoad(pageTbl, x+ivec3(0,0,0)).r>0) &&
               (imageLoad(pageTbl, x+ivec3(1,0,0)).r>0) &&
               (imageLoad(pageTbl, x+ivec3(0,1,0)).r>0) &&
               (imageLoad(pageTbl, x+ivec3(1,1,0)).r>0);

      if(t)
        ;//imageStore(pageTbl, at, uvec4(0));
      }
    }
#endif

  uint pageS = 0;
  if(all(lessThan(at, size)))
    pageS = imageLoad(pageTbl, at).r;
  pageVal[id.x][id.y] = pageS;
  barrier();

  // only 2x2 for now
  if(id.x%2==0 && id.y%2==0) {
    uint pageL = pageVal[id.x+1][id.y+0];
    uint pageR = pageVal[id.x+0][id.y+1];
    uint pageD = pageVal[id.x+1][id.y+1];

    if(pageS==1 && pageL==1 && pageR==1 && pageD==1) {
      pageS                   = 2;
      pageVal[id.x+0][id.y+0] = 2;
      pageVal[id.x+1][id.y+0] = 0;
      pageVal[id.x+0][id.y+1] = 0;
      pageVal[id.x+1][id.y+1] = 0;
      }
    }
  barrier();

  if(pageS>1) {
    imageStore(pageTbl, at+ivec3(0,0,0), uvec4(pageS,0,0,0));
    imageStore(pageTbl, at+ivec3(1,0,0), uvec4(0));
    imageStore(pageTbl, at+ivec3(0,1,0), uvec4(0));
    imageStore(pageTbl, at+ivec3(1,1,0), uvec4(0));
    }
  }
*/
