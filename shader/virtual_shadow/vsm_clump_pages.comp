#version 450

#extension GL_GOOGLE_include_directive    : enable
#extension GL_ARB_separate_shader_objects : enable
#extension GL_EXT_samplerless_texture_functions : enable

#include "virtual_shadow/vsm_common.glsl"
#include "scene.glsl"
#include "common.glsl"

layout(local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, std430) buffer Pages { VsmHeader header; uint  pageList[]; } vsm;
layout(binding = 1, r32ui)  uniform uimage3D pageTbl;

shared uint minY;
shared uint minX  [32/2];
shared uint sWidth[32/2];

void storePage(ivec3 at, uint samples, uint size) {
  uint d = (samples & 0xFF) | (size << 8);
  imageStore(pageTbl, at, uvec4(d));
  }

uvec2 loadPage(ivec3 at) {
  uint a = imageLoad(pageTbl, at).r;
  return uvec2(a&0xFF, a>>8);
  }

uint loadPagePrimeSize(ivec3 at) {
  uint a = imageLoad(pageTbl, at).r;
  return a >> 1;
  }

uint loadPagePrimeBit(ivec3 at) {
  uint a = imageLoad(pageTbl, at).r;
  return a & 0x1;
  }

void storePagePrime(ivec3 at, uint size, uint prime) {
  uint d = (size << 1) | prime&0x1;
  imageStore(pageTbl, at, uvec4(d));
  }

void main() {
  const ivec3 size = imageSize(pageTbl);
  const ivec3 at   = ivec3(gl_GlobalInvocationID);
  const ivec3 id   = ivec3(gl_LocalInvocationID);
  const uint  lane = gl_LocalInvocationIndex;

  if(lane < minX.length()) {
    minX  [lane] = 0xFFFF;
    sWidth[lane] = 0;
    }
  minY = 0xFFFF;
  barrier();

  const uint frag  = imageLoad(pageTbl, at).r;
  const bool prime = frag>0;

  if(frag>0) {
    atomicMin(minY, at.y);

    atomicMin(vsm.header.pageBbox[at.z].x, at.x);
    atomicMin(vsm.header.pageBbox[at.z].y, at.y);
    atomicMax(vsm.header.pageBbox[at.z].z, at.x+1);
    atomicMax(vsm.header.pageBbox[at.z].w, at.y+1);
    }
  barrier();

  const uint stripe = (at.y-minY)/2;
  if(frag>0)
    atomicMin(minX[stripe], at.x);
  barrier();

  if(stripe%2==1 && minX[stripe-1]%2!=minX[stripe]%2) {
    if(minX[stripe-1] > minX[stripe])
      minX[stripe-1]--; else
      minX[stripe-0]--;
    }
  barrier();

  ivec2 tileCoord = ivec2(at.x - minX[stripe], at.y-minY);
  if(frag>0) {
    uint w = tileCoord.x + 1;
    w += w%2;
    atomicMax(sWidth[stripe], w);
    }
  barrier();

  const bool valid = (0<=tileCoord.x && tileCoord.x<sWidth[stripe] && 0<=tileCoord.y);
  const bool quad  = (valid && tileCoord.x%2==0 && tileCoord.y%2==0);
  const bool bQuad = (valid && tileCoord.x%4==0 && tileCoord.y%4==0);
  if(quad) {
    uint a = loadPagePrimeBit(at+ivec3(0,0,0));
    uint b = loadPagePrimeBit(at+ivec3(1,0,0));
    uint c = loadPagePrimeBit(at+ivec3(1,1,0));
    uint d = loadPagePrimeBit(at+ivec3(0,1,0));
    //storePage(at, (a+b+c+d));
    storePage(at, (a+b+c+d), 2);
    } else {
    storePage(at, 0, 0);
    }
  memoryBarrierImage();
  barrier();

  if(true && bQuad) {
    const int mergeQ = (at.z>4 ? 2 : 3)*2;
    uint a = loadPage(at+ivec3(0,0,0)).x;
    uint b = loadPage(at+ivec3(2,0,0)).x;
    uint c = loadPage(at+ivec3(2,2,0)).x;
    uint d = loadPage(at+ivec3(0,2,0)).x;
    uint s = (a+b+c+d);
    if(a+b+c+d >= mergeQ) {
      storePage(at+ivec3(0,0,0), s, 4);
      storePage(at+ivec3(2,0,0), 0, 0);
      storePage(at+ivec3(0,2,0), 0, 0);
      storePage(at+ivec3(2,2,0), 0, 0);
      }
    }

  // prime bit
  memoryBarrierImage();
  barrier();
  {
  uint data = loadPage(at).y;
  data = (data << 1) | (prime ? 1 : 0);
  imageStore(pageTbl, at, uvec4(data));
  }

  // demote unfilled quads to 1x1 pages
  memoryBarrierImage();
  barrier();

  if(true && quad) {
    uint s = loadPagePrimeSize(at);
    uint a = loadPagePrimeBit (at+ivec3(0,0,0));
    uint b = loadPagePrimeBit (at+ivec3(1,0,0));
    uint c = loadPagePrimeBit (at+ivec3(1,1,0));
    uint d = loadPagePrimeBit (at+ivec3(0,1,0));
    if(s==2 && a+b+c+d <= 2) {
      storePagePrime(at+ivec3(0,0,0), a, a);
      storePagePrime(at+ivec3(1,0,0), b, b);
      storePagePrime(at+ivec3(1,1,0), c, c);
      storePagePrime(at+ivec3(0,1,0), d, d);
      }
    }
  }


/*
void trimMip(int mip) {
  const ivec3 size = imageSize(pageTbl);
  const ivec3 id   = ivec3(gl_LocalInvocationID);

  const ivec2 b = ivec2(VSM_PAGE_TBL_SIZE/4);
  const ivec2 h = ivec2(VSM_PAGE_TBL_SIZE/2);

  for(int i=id.x; i<h.x; i+=int(gl_WorkGroupSize.x)) {
    for(int r=id.y; r<h.y; r+=int(gl_WorkGroupSize.y)) {
      ivec3 ax = ivec3(i+b.x, r+b.y, mip);
      uint  st = imageLoad(pageTbl, ax).r;
      if(st==0)
        continue;

      ivec3 at = ivec3(i*2, r*2, mip-1);
      uint  a  = imageLoad(pageTbl, at+ivec3(0,0,0)).r;
      uint  b  = imageLoad(pageTbl, at+ivec3(1,0,0)).r;
      uint  c  = imageLoad(pageTbl, at+ivec3(0,1,0)).r;
      uint  d  = imageLoad(pageTbl, at+ivec3(1,1,0)).r;
      if(a+b+c+d == 4) {
        imageStore(pageTbl, ax, uvec4(0));
        }
      }
    }
  }
*/
