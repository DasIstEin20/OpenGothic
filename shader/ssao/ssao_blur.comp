#version 460
#extension GL_ARB_separate_shader_objects : enable
#extension GL_GOOGLE_include_directive    : enable

#include "scene.glsl"
#include "common.glsl"

layout(local_size_x = 8, local_size_y = 8) in;

const int   KERNEL_RADIUS = 1;
const float blurSharpness = 0.8;

const uint  LANE_SIZE     = gl_WorkGroupSize.x + KERNEL_RADIUS*2 + 1;
const float blurSigma     = float(KERNEL_RADIUS) * 0.5;
const float blurFalloff   = 1.0/(2.0*blurSigma*blurSigma);

layout(binding  = 0) uniform writeonly image2D result;
layout(binding  = 1, std140) uniform UboScene {
  SceneDesc scene;
  };
layout(binding  = 2) uniform sampler2D ssao;
layout(binding  = 3) uniform sampler2D depth;

shared vec2 samples[LANE_SIZE][LANE_SIZE];

vec2 sampleAt(ivec2 at) {
  at += ivec2(KERNEL_RADIUS);
  return samples[at.x][at.y];
  }

void sampleAt(ivec2 at, vec2 s) {
  at += ivec2(KERNEL_RADIUS);
  samples[at.x][at.y] = s;
  }

float texLinearDepth(vec2 uv) {
  float d = textureLod(depth, uv, 0).x;
  return linearDepth(d, scene.clipInfo);
  }

void main() {
  const ivec2 res = ivec2(textureSize(depth,0).xy);

  const ivec2 groupxXY = ivec2(gl_WorkGroupID.xy * gl_WorkGroupSize.xy);
  for(uint i=gl_LocalInvocationID.x; i<LANE_SIZE; i+=gl_WorkGroupSize.x)
    for(uint r=gl_LocalInvocationID.y; r<LANE_SIZE; r+=gl_WorkGroupSize.y) {
      ivec2 xy = ivec2(i,r) - ivec2(KERNEL_RADIUS);
      ivec2 at = groupxXY + xy;
      vec2  uv = (at+vec2(0.5)) / vec2(res);

      float c  = textureLod(ssao, uv, 0).r;
      float d  = texLinearDepth(uv);
      sampleAt(xy, vec2(c,d));
      }

  barrier();

  if(gl_GlobalInvocationID.x>=res.x || gl_GlobalInvocationID.y>=res.y)
    return;

  vec2  center = sampleAt(ivec2(gl_LocalInvocationID.xy));
  float cTotal = center.x;
  float wTotal = 1.0;

  const float R2  = (KERNEL_RADIUS*KERNEL_RADIUS);

  for(int i=-KERNEL_RADIUS; i<=KERNEL_RADIUS; ++i)
    for(int r=-KERNEL_RADIUS; r<=KERNEL_RADIUS; ++r) {
      if(i==0 && r==0)
        continue;

      ivec2 at    = ivec2(gl_LocalInvocationID.xy) + ivec2(i,r);
      vec2  smp   = sampleAt(at);

      float ddiff = (smp.y - center.y) * blurSharpness;
      float w     = exp2(-R2*blurFalloff - ddiff*ddiff);

      cTotal += w*smp.x;
      wTotal += w;
      }

  float v = clamp(cTotal/wTotal, 0, 1);
  imageStore(result, ivec2(gl_GlobalInvocationID.xy), vec4(v));

  //float c  = textureLod(ssao, vec2(gl_GlobalInvocationID.xy+vec2(0.5))/vec2(res), 0).r;
  //imageStore(result, ivec2(gl_GlobalInvocationID.xy), vec4(c));
  }
